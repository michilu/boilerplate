// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package domain

import (
	"context"
	"time"

	"github.com/michilu/boilerplate/v/errs"
	"google.golang.org/grpc/codes"
)

// GetPipeUpdate returns new input(chan<- TimeTime)/output(<-chan Durationer) channels that embedded the given 'func(TimeTime) Durationer'.
func GetPipeUpdate(
	ctx context.Context,
	fn func(time.Time) (Durationer, error),
	fnErr func(error) bool,
) (
	chan<- time.Time,
	<-chan Durationer,
) {
	const op = "pipe.GetPipeUpdate"

	if ctx == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'ctx' is nil"})
	}
	if fn == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'fn' is nil"})
	}
	if fnErr == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'fnErr' is nil"})
	}

	inCh := make(chan time.Time)
	outCh := make(chan Durationer)

	go func() {
		const op = op + "#go"
		defer close(outCh)
		for i := range inCh {
			o, err := fn(i)
			if err != nil {
				if fnErr(&errs.Error{Op: op, Err: err}) {
					return
				}
				continue
			}
			select {
			case <-ctx.Done():
				err := ctx.Err()
				if err != nil {
					fnErr(&errs.Error{Op: op, Err: err})
				}
				return
			case outCh <- o:
			default:
			}
		}
	}()

	return inCh, outCh
}

// GetFanoutUpdate returns new input(chan<- TimeTime)/output(<-chan Durationer) channels that embedded the given 'func(TimeTime) Durationer'.
func GetFanoutUpdate(
	ctx context.Context,
	fn func(time.Time) ([]Durationer, error),
	fnErr func(error) bool,
) (
	chan<- time.Time,
	<-chan Durationer,
) {
	const op = "pipe.GetFanoutUpdate"

	if ctx == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'ctx' is nil"})
	}
	if fn == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'fn' is nil"})
	}
	if fnErr == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'fnErr' is nil"})
	}

	inCh := make(chan time.Time)
	outCh := make(chan Durationer)

	go func() {
		const op = op + "#go"
		defer close(outCh)
		for i := range inCh {
			o, err := fn(i)
			if err != nil {
				if fnErr(&errs.Error{Op: op, Err: err}) {
					return
				}
				continue
			}
			for _, v := range o {
				select {
				case <-ctx.Done():
					err := ctx.Err()
					if err != nil {
						fnErr(&errs.Error{Op: op, Err: err})
					}
					return
				case outCh <- v:
				default:
				}
			}
		}
	}()

	return inCh, outCh
}
