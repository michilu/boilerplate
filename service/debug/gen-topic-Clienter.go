// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package debug

import (
	"context"
	"sync"

	"github.com/michilu/boilerplate/service/errs"
	"github.com/michilu/boilerplate/service/slog"
	"google.golang.org/grpc/codes"
)

var (
	topicClienter *mapClienter
)

func init() {
	topicClienter = newMapClienter()
}

// GetTopicClienter returns a TopicClienter of the given topic.
func GetTopicClienter(topic interface{}) TopicClienter {
	return topicClienter.get(topic)
}

// TopicClienter is a topic.
type TopicClienter interface {
	// Publish returns a '<-chan Clienter' that joins to the given topic.
	Publish(ctx context.Context, c <-chan Clienter)
	// Publisher returns a 'chan<- Clienter' that joins to the given topic.
	Publisher(ctx context.Context) chan<- Clienter
	// Subscribe returns a 'chan<- Clienter' that joins to the given topic.
	Subscribe(c chan<- Clienter)
}

type tClienter struct {
	mu sync.RWMutex
	c  []chan<- Clienter
}

func newTClienter() *tClienter {
	return &tClienter{
		c: make([]chan<- Clienter, 0),
	}
}

func (t *tClienter) Publish(ctx context.Context, c <-chan Clienter) {
	const op = op + ".tClienter.Publish"

	if ctx == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'ctx' is nil"})
	}
	if c == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'c' is nil"})
	}

	go slog.Recover(ctx, func(ctx context.Context) error {
		const op = op + "#go"
	loop:
		select {
		case <-ctx.Done():
			if err := ctx.Err(); err != nil {
				return &errs.Error{Op: op, Err: err}
			}
			return nil
		default:
		}
		for v := range c {
			v0 := v
			for _, v := range t.c {
				v1 := v
				go slog.Recover(ctx, func(ctx context.Context) error {
					func(c chan<- Clienter, v Clienter) {
						const op = op + "#func"
						select {
						case <-ctx.Done():
							err := &errs.Error{Op: op, Code: codes.Canceled, Err: ctx.Err()}
							slog.Logger().Debug().Err(err).Str("op", op).Msg(err.Error())
							return
						case c <- v:
						}
					}(v1, v0)
					return nil
				})
			}
			goto loop
		}
		return nil
	})

}

func (t *tClienter) Publisher(ctx context.Context) chan<- Clienter {
	const op = op + ".tClienter.Publisher"

	if ctx == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'ctx' is nil"})
	}

	c := make(chan Clienter)
	t.Publish(ctx, c)
	return c
}

func (t *tClienter) Subscribe(c chan<- Clienter) {
	const op = op + ".tClienter.Subscribe"

	if c == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'c' is nil"})
	}

	t.mu.Lock()
	t.c = append(t.c, c)
	t.mu.Unlock()
}

type mapClienter struct {
	m sync.Map
}

func newMapClienter() *mapClienter {
	return &mapClienter{}
}

func (m *mapClienter) get(topic interface{}) TopicClienter {
	const op = op + ".mapClienter.get"

	if topic == nil {
		panic(&errs.Error{Op: op, Code: codes.InvalidArgument, Message: "must be given. 'topic' is nil"})
	}

	v0, ok := m.m.Load(topic)
	if ok {
		if v1, ok := v0.(TopicClienter); ok {
			return v1
		}
	}

	v2 := newTClienter()
	m.m.Store(topic, v2)
	return v2
}
